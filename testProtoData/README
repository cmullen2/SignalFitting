This README covers 2 features :
(1) perform ML fits correcting for detector acceptance by integrating over MC data
(2) include experimental polarisation state luminosity asymmetries in calculation of normaisation integrals. This is done by taking values of polarisation and polarisation state directly from the data tree and copying to the simulated tree.
This would be useful for cases using coherent brem for linear polarisaed photons or a polarised target when you run for different times in different directions
//////////////////////////////////////////////////////////////////////////
You must have a copy of the HaSpect code, set the enviroment variable HSANA to its full path and copy the $HSANA/rootrc to ~/.rootrc or at least copy the lines of code from $HSANA/rootrc to your own .rootrc

    setenv HSANA /path_to_haspect_classes/
    cp $HSANA/rootrc ~/.rootrc
See HSDoc for further details on the HS root enviroment 
/////////////////////////////////////////////////////////////////////////
Detector Acceptance
When performing a Extended Maximum Likelihood fit on must integrate over the fit function to normalise the PDF this has to include acceptance. This can be done using simulated data to numerically calculate the intergral by summing the fit function over events.
This is done by supplying the RooHSAbsEventsPDF class with a tree of MC data. The class will then handle the integration, including partial integration required for projecting the PDF into 1D.

////////////////////////////////////////////////////////////
Data generation
The macro PseudoData.C can produce pseudodata with sin2phi model + acceptance + resolution effects.
It can also produce similar pseudosimulated data with flat phi dependence + acceptance + resolution. You should generate at leat 10X simulated data for use in MCStudy.
To produce data run :
   root 'PseudoData.C( "DataASymRes10PS02.root" ,10000,10,1,0.2,kFALSE)'
These arguemnts produce output file DataSymRes10PS02.root with 10k events, a symmetric acceptance function and Phi resolution of 10 degrees and a polarisation luminosity asymmetry of +0.2. For more details see PseudoData.C.
Default model :
1 + PolState*Pol*(0.4*cos(2*TMath::DegToRad()*Phi) - 0.6*sin(2*TMath::DegToRad()*Phi))
To produce Sim run :
   root 'PseudoData.C("SimASymRes10.root",100000,10,1,0,kTRUE)'
This produces equivalent simulated file SimDataSymRes10.root with flat Phi distrribution. There is no PolState assigned for simulated data instead this will be taken from the data file.

The main tree branches used here are :
    Phi and genPhi - the detected and true phi
    Pol - the "linear polarisation" which is just a function of Eg and has no resolution effects so Pol = genPol = Eg/2-1 (i.e range 0.5-1)
    PolState = + or -
    Eg = "Beam energy" flat between 3 and 4
    UID = unique event ID, may be need for weight synchronisation in future
    others = some typcial kinematics which are not used in this example

Note :	   genPhi is only written for simulation
     	   Pol and PolState is only written for Data, Sim will "steal" these
/////////////////////////////////////////////////////////////////////////////
Making your fit function

RooFit autogenerate custom pdf classes via the RooClassFactory. Here we extend this to pdfs inheriting from RooHSAbsEventsPDF - the class that handles simulated event trees for PDF integration and model event generation.
To make the skeleton code we use the THSSkeleton class :
   root --THSSkeleton.C
   root [1] THSSkeleton skel;
   root [2] skel.CreateRooFitEventsPDF("SKNewPDF","Phi,Pol,CAT:PolState","A,B")

This creates a PDF that will fit variables in the input tree called Phi and Pol, with a RooCategory PolState (for asymmmetries) and with fit parameters called A and B. The user now has to define the fit function themselves. Open MyNewPDF.cxx; scrolll down to the evaluate() function (Nothing else should need edited) Replace the default return 1.0; with a suitable fit function :
Double_t MyNewPDF::evaluate() const 
 { 
  return 1.0 + PolState*Pol*(A*TMath::Cos(2*TMath::DegToRad()*Phi)+B*TMath::Sin(2*TMath::DegToRad()*Phi));
 } 
Similar for evaluateMC() :

Double_t MyNewPDF::evaluateMC() const {
// ENTER IDENTICAL EXPRESSION TO evaluate() IN TERMS OF MC VARIABLE ARGUMENTS HERE
  Double_t mcPhi=fMCVar[0];
  Double_t mcPol=fMCVar[1];
  Int_t mcPolState=fMCCat[0];
  return 1.0 + mcPolState*mcPol*(A*TMath::Cos(2*TMath::DegToRad()*mcPhi)+B*TMath::Sin(2*TMath::DegToRad()*mcPhi)); 
}

Note the lines Double_t mcPhi=fMCVar[0]; are generated by the skelton code
Note the only difference between the functions is Phi->mcPhi and Pol->mcPol

That should be the PDF completed.
//////////////////////////////////////////////////////////////////////////
Fitting 1) all the data together
**The recommended method is to always use binning and cuts (even for 1 bin and no cuts). This is shown in Fitting 2) below. This garuntees the events in the MC and  data files have same cuts applied.
An example fit macro is given in FitHSAsymmetry.C
It uses the THSRooFit class for configuring the fit process.
It needs and output directory
   	 RF->SetOutDir("out/");
Obervables to fit a function on
	 RF->LoadVariable("Phi[-180,180]");//going to fit this
  	 RF->LoadVariable("Pol[0,1]");
	 RF->LoadVariable("PolState[Polp=1,Polm=-1]");//Load a category
Your new PDF with names of variables and fit parameters
     RF->Factory("SKNewPDF::SigAsym( Phi,Pol,A[0.4,-1,1],B[-0.8,-1,1] )");
     RF->LoadSpeciesPDF("SigAsym");
Note number inside [] are initial values and ranges for fit paramters
The PDF now needs the simulated data file
    RooHSEventsPDF* PDF=dynamic_cast<RooHSEventsPDF*>(RF->GetWorkSpace()->pdf("SigAsym")); 
    TChain *chainMC=new TChain("MyModel");
    chainMC->Add("SimSymRes10.root");
    PDF->SetEvTree(chainMC);
There are options to :
Fix the number of entries to integrate over
  //PDF->SetNInt(1E4);
Set the integral to be constant
  //PDF->SetConstInt();
Check if integral is constant by randomising parameters many times and recalculating itegral
   //PDF->CheckIntegralParDep(4);
Note 4= number of tests per dimension, so here we have 2 dimesnions Phi and Pol so it will attempt 4^2=16 integral calulations.
BEWARE LARGE NUMBERS OF DIMENSIONS!!!!!!
Create the total PDF for extended maximum likelihood fit
This automatically creates a yield parameter for each PDF loaded (here we have only 1)
     RF->TotalPDF();

Now add the data to be fitted :
  TChain *chainData=new TChain("MyModel");
  chainData->Add("DataSymRes10PS02.root");
  RF->LoadDataSet(chainData);
Tell the events PDF to take the PolState and Pol from the data chain  
  PDF->AddProtoData(RF->GetDataSet());
Configure the MCStudy :
  RF->SetStudyPDF("SigAsym"); //study this PDF
  RF->SetNStudyTrials(20);  //Perform 20 trials
  //RF->SetStudyPlot();  //Produce plots for each trial fit

And do fit and study results !
    RF->FitAndStudy(1);
Note 1 = number of times to try main fit with different radnomised parametersnpc

Now run fit with hsfit classes:
    root --hsfit FitHSAsymmetry.C --SKNewPDF.cxx

The fitplots will be found in outRes10/ResultsAFit.root
The parameter study and pulls will be found in outRes10/StudyAFit_Study_20_.root
////////////////////////////////////////////////////////////
Fitting 2) Splitting the input file/making cuts...
** this is the recommended method
A) Split the data and make cuts using the script ConfigureBins.C
Create THSRooFit manager and give an output file to save split trees
  THSRooFit* RF=new THSRooFit("Binner");
  RF->SetOutDir("outRes10Bins/");
Load the variables. You must include the generated branches as AuxVariables, this implies they will not be fitted but will be kept in the tree
  ///////////////////////////////Load Variables
  RF->LoadAuxVars("Phi[-10,10]");
  RF->LoadAuxVars("Pol[-10,10]");
  RF->LoadAuxVars("PolState[-10,10]");
BinVars can be used to split data and perfom many fits at different kinematics
They can also be used to apply cuts by using 1 bin. You can apply bins to as many other variables as you like
  RF->LoadBinVars("Eg",4,3,4); //Just make 4 bins in Eg
**You must Load at least 1 BinVar here!
Load a data chain
  TChain chain("MyModel");
  chain.Add("DataASymRes10PS02.root");
 Split the data and save new tree in directory called "outRes10Bins/Eg3.50_/TreeData.root". The Eg.3.50 is constructed from the bin midpoint and variable.
  RF->MakeBinnedTrees(chainData,"Data");
  ***The "Data" string is important!!
Simliar for the MC data, but now the name given must correspond to the PDF name you are going to use for the fit. Here I use the name "Sim". This means whe I construct my PDF using the factory in the Fit script it will start like:
RF->Factory("SKNewPDF::Sim( Phi,Pol.....
  TChain *chainmc=new TChain("MyModel","mcsignal");
  chainmc->Add("SimASymRes10.root");
  RF->MakeBinnedTrees(chainmc,"Sim");//Note "Sim" will be used to name PDF

This macro can be run via:
  root --hsfit ConfigureBins.C

B) fit the data. This is actually simpler than fitting the whole data as the bins can be used to help configure and run the fit. It is shown in FitHSAsymmetryBins.C
As before
  THSRooFit* RF=new THSRooFit("AFit");
  RF->SetOutDir("outRes10Bins/Fits"); //save in Fits dir
Load Variables, you no longer need mention the binned variables, these are already handled. Just call  ConfigureSavedBins with the name of the output dir given in ConfigureBins.C
  RF->ConfigureSavedBins("outRes10Bins/"); 
Make the PDF SigAsym using the same name as for ConfigureBins  RF->Factory("SKNewPDF::SigAsym( Phi,Pol,A[0.4,-1,1],B[-0.8,-1,1] )");
  RF->LoadSpeciesPDF("SigAsym");
  RF->TotalPDF();
Note TotalPDF just totals up all the loaded PDFS and fits those. So in principle you could fit signal and background at the same time for example.  PDF->CheckIntegralParDep(4);
Check for constant integral with 4 fits per parameter dimension here 4^2=16
  PDF->CheckIntegralParDep(4);
Configure the after-fit study to be 5 trials on SigAsym
  RF->SetStudyPDF("SigAsym");
  RF->SetNStudyTrials(5);
  RF->FitSavedBins(1);

This macro can be ran as :
root --hsfit FitHSAsymmetryBins.C --SKNewPDF.cxx


C) Running on farm
Once the data is split into bins via ConfigureBins the individual bins 
can also be sent to a farm to run.
The fit that is run is described in FitHSAsymmetryBinsFarm.C and is very similar
to FitHSAsymmetryBins.C.
The difference is just no output directory is given the results will just be written to the binned data directory (or whatever is specified in pbs_run); THSRooFit is given the name of the bin so it saves to a different file;
  //  RF->ConfigureSavedBins("outBins/"); 
  RF->SetBinDir(fileDir+"/"+job); 
and

//  RF->FitSavedBins(1);
  RF->FitBatchBin(1);
